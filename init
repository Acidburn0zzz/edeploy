#!/bin/bash

################################################################################
# extracted from /var/lib/dpkg/info/openssh-server.postinst
################################################################################
get_config_option() {
	option="$1"

	[ -f /etc/ssh/sshd_config ] || return

	# TODO: actually only one '=' allowed after option
	perl -lne 's/\s+/ /g; print if s/^\s*'"$option"'[[:space:]=]+//i' \
	   /etc/ssh/sshd_config
}

host_keys_required() {
	hostkeys="$(get_config_option HostKey)"
	if [ "$hostkeys" ]; then
		echo "$hostkeys"
	else
		# No HostKey directives at all, so the server picks some
		# defaults depending on the setting of Protocol.
		protocol="$(get_config_option Protocol)"
		[ "$protocol" ] || protocol=1,2
		if echo "$protocol" | grep 1 >/dev/null; then
			echo /etc/ssh/ssh_host_key
		fi
		if echo "$protocol" | grep 2 >/dev/null; then
			echo /etc/ssh/ssh_host_rsa_key
			echo /etc/ssh/ssh_host_dsa_key
			echo /etc/ssh/ssh_host_ecdsa_key
		fi
	fi
}

create_key() {
	msg="$1"
	shift
	hostkeys="$1"
	shift
	file="$1"
	shift

	if echo "$hostkeys" | grep -x "$file" >/dev/null && \
	   [ ! -f "$file" ] ; then
		echo -n $msg
		ssh-keygen -q -f "$file" -N '' "$@"
		echo
		if which restorecon >/dev/null 2>&1; then
			restorecon "$file.pub"
		fi
	fi
}


create_keys() {
	hostkeys="$(host_keys_required)"

	create_key "Creating SSH1 key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_key -t rsa1

	create_key "Creating SSH2 RSA key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_rsa_key -t rsa
	create_key "Creating SSH2 DSA key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_dsa_key -t dsa
	create_key "Creating SSH2 ECDSA key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_ecdsa_key -t ecdsa
}

################################################################################

function configure_network() {
    d="$1"
    
    > $d/etc/network/interfaces
    
    IFS=:
    export IFS
    grep : /proc/net/dev | sed 's/ *//' | while read iface rem; do
	iface=$(echo $iface)
	if [ $iface = lo ]; then
	cat >> $d/etc/network/interfaces <<EOF
auto lo
iface lo inet loopback

EOF
	    continue
	else
	cat >> $d/etc/network/interfaces <<EOF
auto $iface
allow-hotplug $iface
iface $iface inet dhcp

EOF
	fi
    done
}

[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
# Some things don't work properly without /etc/mtab.
ln -sf /proc/mounts /etc/mtab

grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."

# Note that this only becomes /dev on the real filesystem if udev's scripts
# are used; which they will be, but it's worth pointing out
if ! mount -t devtmpfs -o mode=0755 udev /dev; then
	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
	mount -t tmpfs -o mode=0755 udev /dev
	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
	[ -e /dev/null ] || mknod /dev/null c 1 3
fi
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
mount -t tmpfs -o "nosuid,size=20%,mode=0755" tmpfs /run
mkdir /run/initramfs
# compatibility symlink for the pre-oneiric locations
ln -s /run/initramfs /dev/.initramfs

if [ -x /etc/init.d/sysklogd ]; then
    /etc/init.d/sysklogd start
fi

if [ -x /etc/init.d/klogd ]; then
    /etc/init.d/klogd start
fi

# It's all over netlink now
echo "" > /proc/sys/kernel/hotplug
	
# Start the udev daemon to process events
/sbin/udevd --daemon --resolve-names=never

# Iterate sysfs and fire off everything; if we include a rule for it then
# it'll get handled; otherwise it'll get handled later when we do this again
# in the main boot sequence.
( /sbin/udevadm trigger --action=add --subsystem-match=block; \
  /sbin/udevadm trigger --action=add --subsystem-nomatch=block; ) &

################################################################################
# Use the system tag to find the role
################################################################################
serial="$(dmidecode -s system-serial-number)"

################################################################################
# Hardware detection starts here
################################################################################

echo "Detecting PCI devices"

for d in $(cut -f2 /proc/bus/pci/devices ); do
    echo $d| sed 's/\(....\)/\1 /'|while read vendor device; do
	grep "pci:v0000${vendor}d0000${device}" /lib/modules/$(uname -r)/modules.alias|while read a n module; do
	    echo -n "Loding $module..."
	    modprobe $module && echo done || echo error
	done
    done
done

echo "Detecting IPMI"

modprobe ipmi_smb
modprobe ipmi_si
modprobe ipmi_devintf

if [ -f /dev/ipmi0 -o -f /dev/ipmi/0 -o -f /dev/ipmidev/0 ]; then
    ipmitool -I open lan print > /tmp/ipmi.info
    ipmimac=$(grep 'MAC Address' /tmp/ipmi.info|sed -e 's/.*: //')
    # Provision IPMI here if needed
    # for example set password and network card in dhcp mode:
    #ipmitool -I open lan set 6 password <your password here>
    #ipmitool -I open lan set 7 password <your password here>
    #ipmitool -I open lan ipsrc dhcp
else
    echo "No IPMI BMC detected"
fi

echo "Starting networking"

if true; then
    create_keys
    /etc/init.d/ssh start
fi

IFS=:
export IFS
grep : /proc/net/dev | sed 's/ *//' | while read iface rem; do
    iface=$(echo $iface)
    if [ $iface = lo ]; then
	continue
    fi

    echo -n "Waiting for $iface to come up."
    dhclient $iface
    count=30
    while [ $count -gt 0 ] && ! ifconfig $iface|grep -q 'inet addr'; do
	sleep 1
	count=$(($count - 1))
	echo -n .
    done
    if ifconfig $iface|grep -q 'inet addr'; then
	echo done
    else
	echo failed
    fi
done
IFS=

################################################################################
# DEBUG MODE
################################################################################
if true; then
    echo create_keys
    echo /etc/init.d/ssh start
fi

################################################################################
# TODO: we need an exchange with the server to get these settings from the
# system serial number in the future.
################################################################################
SERV=10.0.3.1
RSERV=$SERV
eval $(cat /proc/cmdline | tr ' ' "\n"|grep "^R?SERV=")

cd /
./detect.py > /tmp/hw.py
curl -s -o/configure -F file=@/tmp/hw.py http://${SERV}/cgi-bin/upload.py
chmod +x configure

if ./configure; then

    . /role

    if [ -n "$ROLE" -a -n "$VERS" ]; then
	echo -n "Copying files from ${RSERV}::install/${VERS}/${ROLE}..."
	rsync -a ${RSERV}::install/${VERS}/${ROLE}/ /d/
	echo "SERV=${RSERV}" >> /d/var/lib/edeploy/conf
	echo done
	cat /d/etc/fstab /d/etc/fstab.ext > /d/etc/fstab.new
	cp /d/etc/fstab.new /d/etc/fstab
	rm /d/etc/fstab.ext /d/etc/fstab.new
	mount -obind /dev /d/dev
	chroot /d /bin/bash -c "/usr/sbin/grub-mkconfig -o /boot/grub/grub.cfg"
	if chroot /d /bin/bash -c "/usr/sbin/grub-install ${DISK}"; then
	    configure_network /d
	    umount /d/dev
	    umount -a
	    sync
	    reboot -f
	else
	    echo failed
	fi
    else
	echo "No role or version defined..."
    fi
fi

exec /bin/bash
