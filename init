#!/bin/bash

exec 1>&3
exec 2>&4

exec > /log 2>&1

tail -f /log > /dev/console &
step() {
        echo "################################################################"
        echo "$@"
        echo "################################################################"
}

log() {
	echo "$@"
}

log_n() {
	echo -n "$@"
}

################################################################################
# extracted from /var/lib/dpkg/info/openssh-server.postinst
################################################################################
get_config_option() {
	option="$1"

	[ -f /etc/ssh/sshd_config ] || return

	# TODO: actually only one '=' allowed after option
	perl -lne 's/\s+/ /g; print if s/^\s*'"$option"'[[:space:]=]+//i' \
	   /etc/ssh/sshd_config
}

host_keys_required() {
	hostkeys="$(get_config_option HostKey)"
	if [ "$hostkeys" ]; then
		echo "$hostkeys"
	else
		# No HostKey directives at all, so the server picks some
		# defaults depending on the setting of Protocol.
		protocol="$(get_config_option Protocol)"
		[ "$protocol" ] || protocol=1,2
		if echo "$protocol" | grep 1 >/dev/null; then
			echo /etc/ssh/ssh_host_key
		fi
		if echo "$protocol" | grep 2 >/dev/null; then
			echo /etc/ssh/ssh_host_rsa_key
			echo /etc/ssh/ssh_host_dsa_key
			echo /etc/ssh/ssh_host_ecdsa_key
		fi
	fi
}

create_key() {
	msg="$1"
	shift
	hostkeys="$1"
	shift
	file="$1"
	shift

	if echo "$hostkeys" | grep -x "$file" >/dev/null && \
	   [ ! -f "$file" ] ; then
		echo -n $msg
		ssh-keygen -q -f "$file" -N '' "$@"
		echo
		if which restorecon >/dev/null 2>&1; then
			restorecon "$file.pub"
		fi
	fi
}


create_keys() {
	hostkeys="$(host_keys_required)"

	create_key "Creating SSH1 key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_key -t rsa1

	create_key "Creating SSH2 RSA key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_rsa_key -t rsa
	create_key "Creating SSH2 DSA key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_dsa_key -t dsa
	create_key "Creating SSH2 ECDSA key; this may take some time ..." \
		"$hostkeys" /etc/ssh/ssh_host_ecdsa_key -t ecdsa
}

################################################################################

function configure_network() {
    d="$1"
    
    > $d/etc/network/interfaces
    
    IFS=:
    export IFS
    grep : /proc/net/dev | sed 's/ *//' | while read iface rem; do
	iface=$(echo $iface)
	if [ $iface = lo ]; then
	cat >> $d/etc/network/interfaces <<EOF
auto lo
iface lo inet loopback

EOF
	    continue
	else
	cat >> $d/etc/network/interfaces <<EOF
auto $iface
allow-hotplug $iface
iface $iface inet dhcp

EOF
	fi
    done
}

step "Create directories"
[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
mkdir -p /var/lock

step "Mounting virtual fs"
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc
# Some things don't work properly without /etc/mtab.
ln -sf /proc/mounts /etc/mtab

grep -q '\<quiet\>' /proc/cmdline || log "Loading, please wait..."

# Note that this only becomes /dev on the real filesystem if udev's scripts
# are used; which they will be, but it's worth pointing out
if ! mount -t devtmpfs -o mode=0755 udev /dev; then
	log "W: devtmpfs not available, falling back to tmpfs for /dev"
	mount -t tmpfs -o mode=0755 udev /dev
	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
	[ -e /dev/null ] || mknod /dev/null c 1 3
fi
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
mount -t tmpfs -o "nosuid,size=20%,mode=0755" tmpfs /run
mkdir /run/initramfs
# compatibility symlink for the pre-oneiric locations
ln -s /run/initramfs /dev/.initramfs

step "Starting services"
if [ -x /etc/init.d/sysklogd ]; then
    /etc/init.d/sysklogd start
fi

if [ -x /etc/init.d/klogd ]; then
    /etc/init.d/klogd start
fi

# It's all over netlink now
echo "" > /proc/sys/kernel/hotplug

step "Start Udev"	
# Start the udev daemon to process events
/sbin/udevd --daemon --resolve-names=never

# Iterate sysfs and fire off everything; if we include a rule for it then
# it'll get handled; otherwise it'll get handled later when we do this again
# in the main boot sequence.
( /sbin/udevadm trigger --action=add --subsystem-match=block; \
  /sbin/udevadm trigger --action=add --subsystem-nomatch=block; ) &

################################################################################
# Use the system tag to find the role
################################################################################
serial="$(dmidecode -s system-serial-number)"

################################################################################
# Hardware detection starts here
################################################################################

step "Detecting PCI devices"

for d in $(cut -f2 /proc/bus/pci/devices ); do
    echo $d| sed 's/\(....\)/\1 /'|while read vendor device; do
	grep "pci:v0000${vendor}d0000${device}" /lib/modules/$(uname -r)/modules.alias|while read a n module; do
	    log_n "Loading $module "
	    modprobe $module && log "done" || log "error"
	done
    done
done

step "Detecting IPMI"

modprobe ipmi_smb
modprobe ipmi_si
modprobe ipmi_devintf

if [ -f /dev/ipmi0 -o -f /dev/ipmi/0 -o -f /dev/ipmidev/0 ]; then
    ipmitool -I open lan print > /tmp/ipmi.info
    ipmimac=$(grep 'MAC Address' /tmp/ipmi.info|sed -e 's/.*: //')
    # Provision IPMI here if needed
    # for example set password and network card in dhcp mode:
    #ipmitool -I open lan set 6 password <your password here>
    #ipmitool -I open lan set 7 password <your password here>
    #ipmitool -I open lan ipsrc dhcp
else
    log "No IPMI BMC detected"
fi

step "Starting networking"

if true; then
    create_keys
    /etc/init.d/ssh start
fi

# Let's wait 15 seconds to get a DHCP answer
# Default is very very long....
sed -i "s/^\#timeout.*/timeout 15/g" /etc/dhcp/dhclient.conf

IFS=:
export IFS
FOUND_DHCP=NONE
MAX_RUN=3
RUN=0
while [ "$FOUND_DHCP" = "NONE" ]; do
	#Only consider interface that have a Link ok
	#grep : /proc/net/dev | sed 's/ *//' | while read iface rem; do
	log "Waiting a few seconds to catch network link"
	sleep 5
	IFACES=$(mii-tool | grep "link ok"  | cut -d ":" -f1)
	if [ -z "$IFACES" ]; then
		log "No link detected, switching to iterative discovery"
		IFACES=$(grep ':' /proc/net/dev | sed 's/ *//' | cut -d ':' -f 1)
	fi

	IFACES_NAME=$(echo $IFACES | tr '\n' ',')
	log "Valid Network Interfaces are : $IFACES_NAME"
	echo $IFACES | while read iface rem; do
	     iface=$(echo $iface)
	     if [ $iface = lo ]; then
	       continue
	     fi

	    log_n "Waiting for $iface to come up."
	    dhclient $iface
	    count=10
	    while [ $count -gt 0 ] && ! ifconfig $iface|grep -q 'inet addr'; do
		sleep 1
		count=$(($count - 1))
		log_n .
	    done
	    if ifconfig $iface|grep -q 'inet addr'; then
		FOUND_DHCP="YES"
		log "done"
		break
	    else
		log failed
	    fi
	done

	RUN=$(( $RUN + 1 ))
	if [ "$RUN" != "$MAX_RUN" ]; then
		log "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		log "!! NO DHCP FOUND ! Waiting 10 seconds before trying again ($RUN / $MAX_RUN) !!"
		log "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	else
		log "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		log "!! NO DHCP FOUND after $RUN tries. Rebooting in 10 seconds !!"
		log "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		sleep 10
		echo b > /proc/sysrq-trigger
	fi

done
ip a > /dev/console

if [ "$FOUND_DHCP" = "NONE" ]; then
	sleep 10
	echo b > /proc/sysrq-trigger
fi

IFS=

################################################################################
# TODO: we need an exchange with the server to get these settings from the
# system serial number in the future.
################################################################################
SERV=10.0.3.1
RSERV=$SERV
eval $(cat /proc/cmdline | tr ' ' "\n" | egrep "^R?SERV=")

cd /
./detect.py > /tmp/hw.py
curl -s -o/configure -F file=@/tmp/hw.py http://${SERV}/cgi-bin/upload.py
chmod +x configure

mkdir -p /chroot

if ./configure; then

    . /role

    if [ -n "$ROLE" -a -n "$VERS" ]; then
	log "Copying files from ${RSERV}::install/${VERS}/${ROLE}..."
	rsync -a ${RSERV}::install/${VERS}/${ROLE}/ /chroot/
	echo "SERV=${RSERV}" >> /chroot/var/lib/edeploy/conf
	log "done"
	cat /chroot/etc/fstab /chroot/etc/fstab.ext > /chroot/etc/fstab.new
	cp /chroot/etc/fstab.new /chroot/etc/fstab
	rm /chroot/etc/fstab.ext /chroot/etc/fstab.new
	mount -obind /dev /chroot/dev
	chroot /chroot /bin/bash -c "/usr/sbin/grub-mkconfig -o /boot/grub/grub.cfg"
	
	if [ -d /chroot/var/log ]; then
	    cp /log /chroot/var/log/install.log
	fi
	
	if chroot /chroot /bin/bash -c "/usr/sbin/grub-install ${DISK}"; then
	    configure_network /chroot
	    umount /chroot/dev
	    umount -a
	    sync
	    reboot -f
	else
	    log failed
	fi
    else
	log "No role or version defined..."
    fi
else
    log "Problem during configuration of disks"
    if [ -d /chroot/var/log ]; then
	cp /log /chroot/var/log/install.log
    fi
fi

exec 3>&1
exec 4>&2

exec /bin/bash
